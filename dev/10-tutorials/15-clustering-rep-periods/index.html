<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 4: Representative Periods with Tulipa Clustering · TulipaEnergyModel.jl</title><meta name="title" content="Tutorial 4: Representative Periods with Tulipa Clustering · TulipaEnergyModel.jl"/><meta property="og:title" content="Tutorial 4: Representative Periods with Tulipa Clustering · TulipaEnergyModel.jl"/><meta property="twitter:title" content="Tutorial 4: Representative Periods with Tulipa Clustering · TulipaEnergyModel.jl"/><meta name="description" content="Documentation for TulipaEnergyModel.jl."/><meta property="og:description" content="Documentation for TulipaEnergyModel.jl."/><meta property="twitter:description" content="Documentation for TulipaEnergyModel.jl."/><meta property="og:url" content="https://TulipaEnergy.github.io/TulipaEnergyModel.jl/10-tutorials/15-clustering-rep-periods/"/><meta property="twitter:url" content="https://TulipaEnergy.github.io/TulipaEnergyModel.jl/10-tutorials/15-clustering-rep-periods/"/><link rel="canonical" href="https://TulipaEnergy.github.io/TulipaEnergyModel.jl/10-tutorials/15-clustering-rep-periods/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="TulipaEnergyModel.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TulipaEnergyModel.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../11-setting-up/">Setting up</a></li><li><a class="tocitem" href="../12-basics/">Tutorial 1: The Basics</a></li><li><a class="tocitem" href="../13-assets/">Tutorial 2: Assets and Flows</a></li><li><a class="tocitem" href="../14-fully-flexible-time/">Tutorial 3: Flexible Time Resolution</a></li><li class="is-active"><a class="tocitem" href>Tutorial 4: Representative Periods with Tulipa Clustering</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Set-up-the-environment"><span>Set up the environment</span></a></li><li><a class="tocitem" href="#Set-up-the-workflow"><span>Set up the workflow</span></a></li><li><a class="tocitem" href="#Adding-TulipaClustering"><span>Adding <code>TulipaClustering</code></span></a></li><li><a class="tocitem" href="#The-Script-as-a-Whole"><span>The Script as a Whole</span></a></li><li><a class="tocitem" href="#Working-with-the-New-Tables-Created-by-TulipaClustering"><span>Working with the New Tables Created by TulipaClustering</span></a></li></ul></li><li><a class="tocitem" href="../16-storage/">Tutorial 5: Seasonal and Non-seasonal Storage</a></li><li><a class="tocitem" href="../17-multi-year-investments/">Tutorial 6: Multi-year investments</a></li><li><a class="tocitem" href="../30-workflow/">Tutorial 7: Workflow</a></li><li><a class="tocitem" href="../99-manual-steps/">Advanced Control</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../20-user-guide/00-getting-started/">Getting Started</a></li><li><a class="tocitem" href="../../20-user-guide/20-how-to-use/">How to Use</a></li><li><a class="tocitem" href="../../20-user-guide/50-schemas/">Analysis Workflow</a></li><li><a class="tocitem" href="../../20-user-guide/55-outputs/">Output Variables</a></li><li><a class="tocitem" href="../../20-user-guide/60-structures/">Internal Model Structures</a></li></ul></li><li><a class="tocitem" href="../../30-concepts/">Concepts</a></li><li><span class="tocitem">Scientific Foundation</span><ul><li><a class="tocitem" href="../../40-scientific-foundation/40-formulation/">Mathematical Formulation</a></li><li><a class="tocitem" href="../../40-scientific-foundation/45-scientific-references/">Scientific References</a></li></ul></li><li><a class="tocitem" href="../../70-reference/">API Reference</a></li><li><a class="tocitem" href="../../80-ecosystem/">Tulipa Ecosystem</a></li><li><span class="tocitem">Contributing</span><ul><li><a class="tocitem" href="../../90-contributing/90-contributing/">Contributing Guidelines</a></li><li><a class="tocitem" href="../../90-contributing/91-developer/">Developer Documentation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Tutorial 4: Representative Periods with Tulipa Clustering</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial 4: Representative Periods with Tulipa Clustering</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TulipaEnergy/TulipaEnergyModel.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/TulipaEnergy/TulipaEnergyModel.jl/blob/main/docs/src/10-tutorials/15-clustering-rep-periods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-4:-Representative-Periods-with-Tulipa-Clustering"><a class="docs-heading-anchor" href="#Tutorial-4:-Representative-Periods-with-Tulipa-Clustering">Tutorial 4: Representative Periods with Tulipa Clustering</a><a id="Tutorial-4:-Representative-Periods-with-Tulipa-Clustering-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-4:-Representative-Periods-with-Tulipa-Clustering" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Using representative periods is a simplification method to reduce the size of the problem. Instead of solving for every time period, the model solves for a few chosen representatives of the data. The original data is then reconstructed or approximated by blending the representatives.</p><p>Tulipa uses the package <a href="https://github.com/TulipaEnergy/TulipaClustering.jl">TulipaClustering.jl</a> to choose representatives and cluster input data.</p><h2 id="Set-up-the-environment"><a class="docs-heading-anchor" href="#Set-up-the-environment">Set up the environment</a><a id="Set-up-the-environment-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-environment" title="Permalink"></a></h2><p>Add the new packages:</p><pre><code class="language-julia hljs">using Pkg: Pkg
Pkg.activate(&quot;.&quot;)
Pkg.add(name=&quot;TulipaClustering&quot;)
Pkg.add(&quot;Distances&quot;)</code></pre><p>Import packages:</p><pre><code class="language-julia hljs">import TulipaIO as TIO
import TulipaEnergyModel as TEM
import TulipaClustering as TC
using DuckDB
using DataFrames
using Plots
using Distances</code></pre><blockquote><p><strong>Question:</strong> Do you remember how to install the two new libraries into your environment?</p></blockquote><h2 id="Set-up-the-workflow"><a class="docs-heading-anchor" href="#Set-up-the-workflow">Set up the workflow</a><a id="Set-up-the-workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-workflow" title="Permalink"></a></h2><p>The data for this tutorial can be found in the folder <code>my-awesome-energy-system/tutorial-4</code></p><p>Load the data:</p><pre><code class="language-julia hljs">connection = DBInterface.connect(DuckDB.DB)
input_dir = &quot;my-awesome-energy-system/tutorial-4&quot;
output_dir = &quot;my-awesome-energy-system/tutorial-4/results&quot;
TIO.read_csv_folder(connection, input_dir)</code></pre><div class="admonition is-warning" id="Warning-20944eacfe0399f"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-20944eacfe0399f" title="Permalink"></a></header><div class="admonition-body"><p>Since the output directory does not exist yet, we need to create the &#39;results&#39; folder inside our tutorial folder, otherwise it will error later.</p></div></div><p>Try to run the problem as usual:</p><pre><code class="language-julia hljs">TEM.populate_with_defaults!(connection)
energy_problem = TEM.run_scenario(connection; output_folder=output_dir)</code></pre><p>Uh oh! It doesn&#39;t work. Why not?</p><pre><code class="language-txt hljs">ERROR: DataValidationException: The following issues were found in the data:
- Column &#39;rep_period&#39; of table &#39;rep_periods_data&#39; does not have a default</code></pre><p>Because we need data from the clustering!</p><h2 id="Adding-TulipaClustering"><a class="docs-heading-anchor" href="#Adding-TulipaClustering">Adding <code>TulipaClustering</code></a><a id="Adding-TulipaClustering-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-TulipaClustering" title="Permalink"></a></h2><p>We need to produce representative period data from the base period data.</p><h3 id="Splitting-the-Profile-Data-into-Periods"><a class="docs-heading-anchor" href="#Splitting-the-Profile-Data-into-Periods">Splitting the Profile Data into Periods</a><a id="Splitting-the-Profile-Data-into-Periods-1"></a><a class="docs-heading-anchor-permalink" href="#Splitting-the-Profile-Data-into-Periods" title="Permalink"></a></h3><p>Let&#39;s say we want to split the year into days, i.e., periods of length 24. <code>TulipaClustering</code> provides two methods that can help: <code>combine_periods!</code> combines existing periods into consequentive timesteps, and <code>split_into_periods!</code> splits it back into periods of desired length:</p><pre><code class="language-julia hljs">period_duration = 24  # group data into days

profiles_df = TIO.get_table(connection, &quot;profiles_periods&quot;)
TC.combine_periods!(profiles_df)
TC.split_into_periods!(profiles_df; period_duration)</code></pre><h3 id="Clustering-the-Data"><a class="docs-heading-anchor" href="#Clustering-the-Data">Clustering the Data</a><a id="Clustering-the-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Clustering-the-Data" title="Permalink"></a></h3><p>We use <code>find_representative_periods</code> to reduce the base periods to RPs. The method has two mandatory positional arguments:</p><ul><li>the profile dataframe,</li><li>the number of representative periods you want to obtain.</li></ul><p>You can also change two optional arguments (after a semicolon):</p><ul><li><code>drop_incomplete_last_period</code> tells the algorithm how to treat the last period if it has fewer timesteps than the other ones (defaults to <code>false</code>),</li><li><code>method</code> clustering method (defaults to <code>:k_means</code>),</li><li><code>distance</code> a metric used to measure how different the datapoints are (defaults to <code>SqEuclidean()</code>),</li></ul><pre><code class="language-julia hljs">num_rep_periods = 7
method = :k_medoids  # :k_means, :convex_hull, :convex_hull_with_null, :conical_hull
distance = Euclidean()  # CosineDist()

clustering_result = TC.find_representative_periods(profiles_df, num_rep_periods; method, distance)</code></pre><p>The <code>clustering_result</code> contains some useful information:</p><ul><li><code>profiles</code> is a dataframe with profiles for RPs,</li><li><code>weight_matrix</code> is a matrix of weights of RPs in blended periods,</li><li><code>clustering_matrix</code> and <code>rp_matrix</code> are matrices of profile data for each base and representative period (useful to keep for the next step, but you should not need these unless you want to do some extra math here)</li><li><code>auxiliary_data</code> contains some extra data that was generated during the clustering process and is generally not interesting to the user who is not planning to interact with the clustering method on a very low level.</li></ul><h3 id="Weight-Fitting"><a class="docs-heading-anchor" href="#Weight-Fitting">Weight Fitting</a><a id="Weight-Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Weight-Fitting" title="Permalink"></a></h3><p>After the clustering is done, each period is assigned to one representative period. We call this a &quot;Dirac assignment&quot; after the Dirac measure: a measure that is concentrated on one item (i.e., one base period is mapped into exactly one representative period).</p><p><code>TulipaClustering</code> supports blended weights for representative periods. To produce these, we use projected gradient descent. You don&#39;t need to know all the math behind it, but it has a few parameters that are useful to understand:</p><ul><li><code>weight_type</code> can be <code>:conical</code> (weights are positive), <code>:conical_bounded</code> (weights are positive, add at most into one), <code>:convex</code> (weights are positive, add into one), <code>:dirac</code> (one unit weight and the rest are zeros). The order here is from less restrictive to more restrictive.</li><li><code>tol</code> is the algorithm&#39;s tolerance. A tolerance of <code>1e-2</code> means that weights are estimated up to two decimal places (e.g., something like <code>0.15</code>).</li><li><code>niters</code> and <code>learning_rate</code> tell for how many iterations to run the descent and by how much to adjust the weights in each iterations. More iterations make the method slower but produce better results. Larger learning rate makes the method converge faster but in a less stable manner (i.e., weights might start going up and down a lot from iteration to iteration). Sometimes you need to find the right balance for yourself. In general, if the weights produced by the method look strange, try decreasing the learning rate and/or increasing the number of iterations.</li></ul><p>Now fit the weights:</p><pre><code class="language-julia hljs">weight_type = :dirac  # :convex, :conical, :conical_bounded
tol = 1e-2
niters = 100
learning_rate = 0.001

TC.fit_rep_period_weights!(
    clustering_result;
    weight_type,
    tol,
    niters,
    learning_rate,
)</code></pre><h3 id="Running-the-Model"><a class="docs-heading-anchor" href="#Running-the-Model">Running the Model</a><a id="Running-the-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-Model" title="Permalink"></a></h3><p>To run the model, add the data to the system with <code>TulipaIO</code> and then run it as usual:</p><pre><code class="language-julia hljs">TC.write_clustering_result_to_tables(connection, clustering_result)

TEM.populate_with_defaults!(connection)
energy_problem = TEM.run_scenario(connection; output_folder=output_dir)</code></pre><h3 id="Interpreting-the-Results"><a class="docs-heading-anchor" href="#Interpreting-the-Results">Interpreting the Results</a><a id="Interpreting-the-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Interpreting-the-Results" title="Permalink"></a></h3><p>To plot the results, first read the data with <code>TulipaIO</code> and filter what&#39;s needed (and rename <code>time_block_start</code> to <code>timestep</code> while you&#39;re at it):</p><pre><code class="language-julia hljs">flows = TIO.get_table(connection, &quot;var_flow&quot;)

select!(
    flows,
    :from_asset,
    :to_asset,
    :year,
    :rep_period,
    :time_block_start =&gt; :timestep,
    :solution
)

from_asset = &quot;ccgt&quot;
to_asset = &quot;e_demand&quot;
year = 2030

filtered_flow = filter(
    row -&gt;
        row.from_asset == from_asset &amp;&amp;
            row.to_asset == to_asset &amp;&amp;
            row.year == year,
    flows,
)</code></pre><p>To reinterpret the RP data as base periods data, first create a new dataframe that contains both by using the inner join operation:</p><pre><code class="language-julia hljs">rep_periods_mapping = TIO.get_table(connection, &quot;rep_periods_mapping&quot;)
df = innerjoin(filtered_flow, rep_periods_mapping, on=[:year, :rep_period])</code></pre><p>Next, use Julia&#39;s Split-Apply-Combine approach to group the dataframe into smaller ones. Each grouped dataframe contains a single data point for one base period and all RPs it maps to. Then multiply the results by weights and add them up.</p><pre><code class="language-julia hljs">gdf = groupby(df, [:from_asset, :to_asset, :year, :period, :timestep])
result_df = combine(gdf, [:weight, :solution] =&gt; ((w, s) -&gt; sum(w .* s)) =&gt; :solution)</code></pre><p>Now you can plot the results. Remove the period data since you don&#39;t need it anymore, and re-sort the data to make sure it is in the right order.</p><pre><code class="language-julia hljs">TC.combine_periods!(result_df)
sort!(result_df, :timestep)

plot(
    result_df.timestep,
    result_df.solution;
    label=string(from_asset, &quot; -&gt; &quot;, to_asset),
    xlabel=&quot;Hour&quot;,
    ylabel=&quot;[MWh]&quot;,
    marker=:circle,
    markersize=2,
    xlims=(1, 168),
    dpi=600,
)</code></pre><p>This concludes this tutorial! Play around with different parameters to see how the results change. For example, when you use <code>:dirac</code> vs <code>:convex</code> weights, do you see the difference? How does the solution change as you increase the number of RPs?</p><h2 id="The-Script-as-a-Whole"><a class="docs-heading-anchor" href="#The-Script-as-a-Whole">The Script as a Whole</a><a id="The-Script-as-a-Whole-1"></a><a class="docs-heading-anchor-permalink" href="#The-Script-as-a-Whole" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Pkg
Pkg.activate(&quot;.&quot;)
# Pkg.add(&quot;TulipaEnergyModel&quot;)
# Pkg.add(&quot;TulipaIO&quot;)
Pkg.add(&quot;TulipaClustering&quot;)
# Pkg.add(&quot;DuckDB&quot;)
# Pkg.add(&quot;DataFrames&quot;)
# Pkg.add(&quot;Plots&quot;)
Pkg.add(&quot;Distances&quot;)

Pkg.instantiate()

import TulipaIO as TIO
import TulipaEnergyModel as TEM
import TulipaClustering as TC
using DuckDB
using DataFrames
using Plots
using Distances

connection = DBInterface.connect(DuckDB.DB)

input_dir = &quot;my-awesome-energy-system/tutorial-4&quot;
output_dir = &quot;my-awesome-energy-system/tutorial-4/results&quot;

TIO.read_csv_folder(connection, input_dir)


period_duration = 24
profiles_df = TIO.get_table(connection, &quot;profiles_periods&quot;)
TC.combine_periods!(profiles_df)
TC.split_into_periods!(profiles_df; period_duration)

num_rep_periods = 2
method = :k_medoids  # :k_means, :convex_hull, :convex_hull_with_null, :conical_hull
distance = Euclidean()  # CosineDist()

clustering_result = TC.find_representative_periods(profiles_df, num_rep_periods; method, distance)

weight_type = :dirac  # :convex, :conical, :conical_bounded
tol = 1e-2
niters = 100
learning_rate = 0.001

TC.fit_rep_period_weights!(
    clustering_result;
    weight_type,
    tol,
    niters,
    learning_rate,
)
TC.write_clustering_result_to_tables(connection, clustering_result)

TEM.populate_with_defaults!(connection)
energy_problem = TEM.run_scenario(connection; output_folder=output_dir)


flows = TIO.get_table(connection, &quot;var_flow&quot;)
select!(
    flows,
    :from_asset,
    :to_asset,
    :year,
    :rep_period,
    :time_block_start =&gt; :timestep,
    :solution
)

from_asset = &quot;ccgt&quot;
to_asset = &quot;e_demand&quot;
year = 2030

filtered_flow = filter(
    row -&gt;
        row.from_asset == from_asset &amp;&amp;
            row.to_asset == to_asset &amp;&amp;
            row.year == year,
    flows,
)


rep_periods_mapping = TIO.get_table(connection, &quot;rep_periods_mapping&quot;)

df = innerjoin(filtered_flow, rep_periods_mapping, on=[:year, :rep_period])
gdf = groupby(df, [:from_asset, :to_asset, :year, :period, :timestep])
result_df = combine(gdf, [:weight, :solution] =&gt; ((w, s) -&gt; sum(w .* s)) =&gt; :solution)
TC.combine_periods!(result_df)
sort!(result_df, :timestep)
plot(
    result_df.timestep,
    result_df.solution;
    label=string(from_asset, &quot; -&gt; &quot;, to_asset),
    xlabel=&quot;Hour&quot;,
    ylabel=&quot;[MWh]&quot;,
    marker=:circle,
    markersize=2,
    xlims=(1, 168),
    dpi=600,
)
</code></pre><h2 id="Working-with-the-New-Tables-Created-by-TulipaClustering"><a class="docs-heading-anchor" href="#Working-with-the-New-Tables-Created-by-TulipaClustering">Working with the New Tables Created by TulipaClustering</a><a id="Working-with-the-New-Tables-Created-by-TulipaClustering-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-the-New-Tables-Created-by-TulipaClustering" title="Permalink"></a></h2><p>You can check the new tables with TulipaIO, for example:</p><pre><code class="language-julia hljs">TIO.get_table(connection,&quot;rep_periods_mapping&quot;)</code></pre><p>If you want to save the intermediary tables created by the clustering, you can do this with DuckDB:</p><pre><code class="language-julia hljs">DuckDB.execute(
    connection,
    &quot;COPY &#39;profiles_rep_periods&#39; TO &#39;profiles-rep-periods.csv&#39; (HEADER, DELIMITER &#39;,&#39;)&quot;,
)</code></pre><p>The new tables are:</p><ul><li>profiles<em>rep</em>periods</li><li>rep<em>periods</em>data</li><li>rep<em>periods</em>mapping</li><li>timeframe_data</li></ul><p>This is useful when you don&#39;t have to rerun the clustering every time.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../14-fully-flexible-time/">« Tutorial 3: Flexible Time Resolution</a><a class="docs-footer-nextpage" href="../16-storage/">Tutorial 5: Seasonal and Non-seasonal Storage »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 9 October 2025 10:01">Thursday 9 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
